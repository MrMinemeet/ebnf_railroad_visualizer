"use strict";import{Token as n,Kind as i}from"./Token.js";import{Syntax as o}from"../wsn/Syntax.js";import{Production as c}from"../wsn/Production.js";import{Term as a}from"../wsn/Term.js";import{Identifier as u}from"../wsn/Identifier.js";import{Expression as d}from"../wsn/Expression.js";import{Factor as r,FactorType as e}from"../wsn/Factor.js";import{Literal as p}from"../wsn/Literal.js";export class Parser{constructor(t){this.scanner=t,this.t=new n(i.unknown),this.la=new n(i.unknown),this.sym=i.unknown,this.idCounter=0}parse(){return this.scan(),this.Syntax()}Syntax(){const t=[];for(;this.sym!==i.eof;)t.push(this.Production());return this.scan(),new o(t,this.idCounter++)}Production(){const t=this.Identifier();this.check(i.assign);const s=this.Expression();return this.check(i.period),new c(t,s,this.idCounter++)}Identifier(){this.sym!==i.ident&&this.throwError(`expected identifier but found '${this.t}'`),this.scan();const t=[];for(const s of this.t.str)t.push(s);return new u(t,this.idCounter++)}Expression(){const t=[];for(t.push(this.Term());this.sym===i.pipe;)this.scan(),t.push(this.Term());return new d(t,this.idCounter++)}Term(){const t=[this.Factor()];for(;this.sym===i.ident||this.sym===i.literal||this.sym===i.quote||this.sym===i.lpar||this.sym===i.lbrace||this.sym===i.lbrack;)t.push(this.Factor());return new a(t,this.idCounter++)}Factor(){let t,s;switch(this.sym){case i.ident:t=new r(e.Identifier,this.Identifier(),this.idCounter++);break;case i.quote:t=new r(e.Identifier,this.Literal(),this.idCounter++);break;case i.lpar:this.scan(),s=this.Expression(),this.check(i.rpar),t=new r(e.Group,s,this.idCounter++);break;case i.lbrace:this.scan(),s=this.Expression(),this.check(i.rbrace),t=new r(e.Repetition,s,this.idCounter++);break;case i.lbrack:this.scan(),s=this.Expression(),this.check(i.rbrack),t=new r(e.Optionally,s,this.idCounter++);break;default:this.throwError(`expected identifier, '"', '(', '{' or '[' but found '${this.t}'`)}return t}Literal(){let t="";return this.check(i.quote),this.sym!==i.literal&&this.throwError(`expected literal but found '${this.la}'`),t=this.la.str,this.scan(),this.check(i.quote),new p(t,this.idCounter++)}check(t){this.sym!==t&&this.throwError(`expected '${t}' but found '${this.t}'`),this.scan()}scan(){this.t=this.la,this.la=this.scanner.next(),this.sym=this.la.kind}throwError(t){const[s,h]=this.scanner.getPosition();throw new Error(`(line ${s}, column ${h}) - ${t}`)}}
